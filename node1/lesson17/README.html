<!-- build time:2016-06-08 20:43:50 --><!doctype html><html class="theme-next mist use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.lug.ustc.edu.cn//css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/static/css/main.css?v=1.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="落月博客,落月,落月助手,落月切牌器,落月官方网站"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.0.1"><meta name="description" content="《使用 promise 替代回调函数》知识点理解 Promise 概念，为什么需要 promise学习 q 的 API，利用 q 来替代回调函数(https://github.com/kriskowal/q )课程内容第五课(https://github.com/alsotang/node-lessons/tree/master/lesson5 )讲述了如何使用 async 来控制并发。async"><meta property="og:type" content="website"><meta property="og:title" content="落月官方网站"><meta property="og:url" content="http://post.zz173.com/node1/lesson17/README.html"><meta property="og:site_name" content="落月官方网站"><meta property="og:description" content="《使用 promise 替代回调函数》知识点理解 Promise 概念，为什么需要 promise学习 q 的 API，利用 q 来替代回调函数(https://github.com/kriskowal/q )课程内容第五课(https://github.com/alsotang/node-lessons/tree/master/lesson5 )讲述了如何使用 async 来控制并发。async"><meta property="og:updated_time" content="2016-04-26T14:20:42.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="落月官方网站"><meta name="twitter:description" content="《使用 promise 替代回调函数》知识点理解 Promise 概念，为什么需要 promise学习 q 的 API，利用 q 来替代回调函数(https://github.com/kriskowal/q )课程内容第五课(https://github.com/alsotang/node-lessons/tree/master/lesson5 )讲述了如何使用 async 来控制并发。async"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:void 0,author:"博主"}}</script><title>| 落月官方网站</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">落月官方网站</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">落月博客post.zz173.com</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-books"><a href="/books.html" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>书</a></li><li class="menu-item menu-item-tools"><a href="/tools.html" rel="section"><i class="menu-item-icon fa fa-fw fa-wrench"></i><br>工具</a></li><li class="menu-item menu-item-blog"><a href="/post" rel="section"><i class="menu-item-icon fa fa-fw fa-pencil-square-o"></i><br>博客</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><h1 id="《使用-promise-替代回调函数》"><a href="#《使用-promise-替代回调函数》" class="headerlink" title="《使用 promise 替代回调函数》"></a>《使用 promise 替代回调函数》</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>理解 Promise 概念，为什么需要 promise</li><li>学习 q 的 API，利用 q 来替代回调函数(<a href="https://github.com/kriskowal/q" target="_blank" rel="external">https://github.com/kriskowal/q</a> )</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>第五课(<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="external">https://github.com/alsotang/node-lessons/tree/master/lesson5</a> )讲述了如何使用 async 来控制并发。async 的本质是一个流程控制。其实在异步编程中，还有一个更为经典的模型，叫做 Promise/Deferred 模型。</p><p>本节我们就来学习这个模型的代表实现：<a href="https://github.com/kriskowal/q" target="_blank" rel="external">q</a></p><p>首先，我们思考一个典型的异步编程模型，考虑这样一个题目：读取一个文件，在控制台输出这个文件内容。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line">fs.readFile(<span class="string">'sample.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(data);</div><br><div class="line">&#125;);</div><br></pre></td></tr></table></figure><p>看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line">fs.readFile(<span class="string">'sample01.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(data);</div><br><div class="line">truefs.readFile(<span class="string">'sample02.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err,data</span>) </span>&#123;</div><br><div class="line">truetrue<span class="built_in">console</span>.log(data);</div><br><div class="line">true&#125;);</div><br><div class="line">&#125;);</div><br></pre></td></tr></table></figure><p>要是读取更多的文件呢?</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line">fs.readFile(<span class="string">'sample01.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><br><div class="line">truefs.readFile(<span class="string">'sample02.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err,data</span>) </span>&#123;</div><br><div class="line">truetruefs.readFile(<span class="string">'sample03.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><br><div class="line">truetruetruefs.readFile(<span class="string">'sample04.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><br><div class="line"></div><br><div class="line">truetruetrue&#125;);</div><br><div class="line">truetrue&#125;);</div><br><div class="line">true&#125;);</div><br><div class="line">&#125;);</div><br></pre></td></tr></table></figure><p>这段代码就是臭名昭著的邪恶金字塔(Pyramid of Doom)。可以使用async来改善这段代码，但是在本课中我们要用promise/defer来改善它。</p><h2 id="promise基本概念"><a href="#promise基本概念" class="headerlink" title="promise基本概念"></a>promise基本概念</h2><p>先学习promise的基本概念。</p><ul><li>promise只有三种状态，未完成，完成(fulfilled)和失败(rejected)。</li><li>promise的状态可以由未完成转换成完成，或者未完成转换成失败。</li><li>promise的状态转换只发生一次</li></ul><p>promise有一个then方法，then方法可以接受3个函数作为参数。前两个函数对应promise的两种状态fulfilled, rejected的回调函数。第三个函数用于处理进度信息。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">promiseSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">truetrue<span class="comment">//当promise状态变成fulfilled时，调用此函数</span></div><br><div class="line">true&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">truetrue<span class="comment">//当promise状态变成rejected时，调用此函数</span></div><br><div class="line">true&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</div><br><div class="line">truetrue<span class="comment">//当返回进度信息时，调用此函数</span></div><br><div class="line">true&#125;);</div><br></pre></td></tr></table></figure><p>学习一个简单的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 获取初始promise</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInitialPromise</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line">  <span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 为promise设置三种状态的回调函数</div><br><div class="line"> */</div><br><div class="line">getInitialPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(success);</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(error);</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(progress);</div><br><div class="line">&#125;);</div><br><div class="line">defer.notify(<span class="string">'in progress'</span>);<span class="comment">//控制台打印in progress</span></div><br><div class="line">defer.resolve(<span class="string">'resolve'</span>);   <span class="comment">//控制台打印resolve</span></div><br><div class="line">defer.reject(<span class="string">'reject'</span>);		<span class="comment">//没有输出。promise的状态只能改变一次</span></div><br></pre></td></tr></table></figure><h2 id="promise的传递"><a href="#promise的传递" class="headerlink" title="promise的传递"></a>promise的传递</h2><p>then方法会返回一个promise，在下面这个例子中，我们用outputPromise指向then返回的promise。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span> (<span class="params">fulfilled</span>) </span>&#123;</div><br><div class="line">true&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">rejected</span>) </span>&#123;</div><br><div class="line">true&#125;);</div><br></pre></td></tr></table></figure><p>现在outputPromise就变成了受 <code>function(fulfilled)</code> 或者 <code>function(rejected)</code>控制状态的promise了。怎么理解这句话呢？</p><ul><li>当function(fulfilled)或者function(rejected)返回一个值，比如一个字符串，数组，对象等等，那么outputPromise的状态就会变成fulfilled。</li></ul><p>在下面这个例子中，我们可以看到，当我们把inputPromise的状态通过defer.resovle()变成fulfilled时，控制台输出fulfilled.</p><p>当我们把inputPromise的状态通过defer.reject()变成rejected，控制台输出rejected</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 通过defer获得promise</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line">true<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</div><br><div class="line"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</div><br><div class="line"> * 将then返回的promise赋给outputPromise</div><br><div class="line"> * function(fulfilled) 和 function(rejected) 通过返回字符串将outputPromise的状态由</div><br><div class="line"> * 未完成改变为fulfilled</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">return</span> <span class="string">'fulfilled'</span>;</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">return</span> <span class="string">'rejected'</span>;</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)，控制台打印'fulfilled: fulfilled'。</div><br><div class="line"> * 当outputPromise状态由未完成变成rejected, 调用function(rejected), 控制台打印'rejected: rejected'。</div><br><div class="line"> */</div><br><div class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成rejected</div><br><div class="line"> */</div><br><div class="line">defer.reject(); <span class="comment">//输出 fulfilled: rejected</span></div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成fulfilled</div><br><div class="line"> */</div><br><div class="line"><span class="comment">//defer.resolve(); //输出 fulfilled: fulfilled</span></div><br></pre></td></tr></table></figure><ul><li>当function(fulfilled)或者function(rejected)抛出异常时，那么outputPromise的状态就会变成rejected</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 通过defer获得promise</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line">true<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</div><br><div class="line"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</div><br><div class="line"> * 将then返回的promise赋给outputPromise</div><br><div class="line"> * function(fulfilled) 和 function(rejected) 通过抛出异常将outputPromise的状态由</div><br><div class="line"> * 未完成改变为reject</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fulfilled'</span>);</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'rejected'</span>);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)。</div><br><div class="line"> * 当outputPromise状态由未完成变成rejected, 调用function(rejected)。</div><br><div class="line"> */</div><br><div class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成rejected</div><br><div class="line"> */</div><br><div class="line">defer.reject();     <span class="comment">//控制台打印 rejected [Error:rejected]</span></div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成fulfilled</div><br><div class="line"> */</div><br><div class="line"><span class="comment">//defer.resolve(); //控制台打印 rejected [Error:fulfilled]</span></div><br></pre></td></tr></table></figure><ul><li>当function(fulfilled)或者function(rejected)返回一个promise时，outputPromise就会成为这个新的promise.</li></ul><p>这样做有什么意义呢? 主要在于聚合结果(Q.all)，管理延时，异常恢复等等</p><p>比如说我们想要读取一个文件的内容，然后把这些内容打印出来。可能会写出这样的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">//错误的写法</span></div><br><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">truefs.readFile(<span class="string">'test.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><br><div class="line">truetrue<span class="keyword">return</span> data;</div><br><div class="line">true&#125;);</div><br><div class="line">&#125;);</div><br></pre></td></tr></table></figure><p>然而这样写是错误的，因为function(fulfilled)并没有返回任何值。需要下面的方式:</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 通过defer获得promise</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line">true<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</div><br><div class="line"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</div><br><div class="line"> * 将then返回的promise赋给outputPromise</div><br><div class="line"> * function(fulfilled)将新的promise赋给outputPromise</div><br><div class="line"> * 未完成改变为reject</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">var</span> myDefer = Q.defer();</div><br><div class="line">truefs.readFile(<span class="string">'test.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><br><div class="line">truetrue<span class="keyword">if</span>(!err &amp;&amp; data) &#123;</div><br><div class="line">truetruetruemyDefer.resolve(data);</div><br><div class="line">truetrue&#125;</div><br><div class="line">true&#125;);</div><br><div class="line">true<span class="keyword">return</span> myDefer.promise;</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'rejected'</span>);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)，控制台打印test.txt文件内容。</div><br><div class="line"> *</div><br><div class="line"> */</div><br><div class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(fulfilled);</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(rejected);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成rejected</div><br><div class="line"> */</div><br><div class="line"><span class="comment">//defer.reject();</span></div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成fulfilled</div><br><div class="line"> */</div><br><div class="line">defer.resolve(); <span class="comment">//控制台打印出 test.txt 的内容</span></div><br></pre></td></tr></table></figure><h2 id="方法传递"><a href="#方法传递" class="headerlink" title="方法传递"></a>方法传递</h2><p>方法传递有些类似于Java中的try和catch。当一个异常没有响应的捕获时，这个异常会接着往下传递。</p><p>方法传递的含义是当一个状态没有响应的回调函数，就会沿着then往下找。</p><ul><li>没有提供function(rejected)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;&#125;)</div><br></pre></td></tr></table></figure><p>如果inputPromise的状态由未完成变成rejected, 此时对rejected的处理会由outputPromise来完成。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 通过defer获得promise</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line">true<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</div><br><div class="line"> * 当inputPromise状态由未完成变成rejected时，这个rejected会传向outputPromise</div><br><div class="line"> */</div><br><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">return</span> <span class="string">'fulfilled'</span></div><br><div class="line">&#125;);</div><br><div class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成rejected</div><br><div class="line"> */</div><br><div class="line">defer.reject(<span class="string">'inputpromise rejected'</span>); <span class="comment">//控制台打印rejected: inputpromise rejected</span></div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成fulfilled</div><br><div class="line"> */</div><br><div class="line"><span class="comment">//defer.resolve();</span></div><br></pre></td></tr></table></figure><ul><li>没有提供function(fulfilled)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="literal">null</span>,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;&#125;)</div><br></pre></td></tr></table></figure><p>如果inputPromise的状态由未完成变成fulfilled, 此时对fulfil的处理会由outputPromise来完成。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 通过defer获得promise</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line">true<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当inputPromise状态由未完成变成fulfil时，传递给outputPromise</div><br><div class="line"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</div><br><div class="line"> * function(fulfilled)将新的promise赋给outputPromise</div><br><div class="line"> * 未完成改变为reject</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="literal">null</span>,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">return</span> <span class="string">'rejected'</span>;</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</div><br><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成rejected</div><br><div class="line"> */</div><br><div class="line"><span class="comment">//defer.reject('inputpromise rejected');</span></div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成fulfilled</div><br><div class="line"> */</div><br><div class="line">defer.resolve(<span class="string">'inputpromise fulfilled'</span>); <span class="comment">//控制台打印fulfilled: inputpromise fulfilled</span></div><br></pre></td></tr></table></figure><ul><li>可以使用fail(function(error))来专门针对错误处理，而不是使用then(null,function(error))</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().fail(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;&#125;)</div><br></pre></td></tr></table></figure><p>看这个例子</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 通过defer获得promise</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line">true<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 当inputPromise状态由未完成变成fulfil时，调用then(function(fulfilled))</div><br><div class="line"> * 当inputPromise状态由未完成变成rejected时，调用fail(function(error))</div><br><div class="line"> * function(fulfilled)将新的promise赋给outputPromise</div><br><div class="line"> * 未完成改变为reject</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">return</span> fulfilled;</div><br><div class="line">&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(<span class="string">'fail: '</span> + error);</div><br><div class="line">&#125;);</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成rejected</div><br><div class="line"> */</div><br><div class="line">defer.reject(<span class="string">'inputpromise rejected'</span>);<span class="comment">//控制台打印fail: inputpromise rejected</span></div><br><div class="line"></div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 将inputPromise的状态由未完成变成fulfilled</div><br><div class="line"> */</div><br><div class="line"><span class="comment">//defer.resolve('inputpromise fulfilled');</span></div><br></pre></td></tr></table></figure><ul><li>可以使用progress(function(progress))来专门针对进度信息进行处理，而不是使用 <code>then(function(success){},function(error){},function(progress){})</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 获取初始promise</div><br><div class="line"> * @private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInitialPromise</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line">  <span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> * 为promise设置progress信息处理函数</div><br><div class="line"> */</div><br><div class="line"><span class="keyword">var</span> outputPromise = getInitialPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</div><br><div class="line"></div><br><div class="line">&#125;).progress(<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(progress);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line">defer.notify(<span class="number">1</span>);</div><br><div class="line">defer.notify(<span class="number">2</span>); <span class="comment">//控制台打印1，2</span></div><br></pre></td></tr></table></figure><h2 id="promise链"><a href="#promise链" class="headerlink" title="promise链"></a>promise链</h2><p>promise链提供了一种让函数顺序执行的方法。</p><p>函数顺序执行是很重要的一个功能。比如知道用户名，需要根据用户名从数据库中找到相应的用户，然后将用户信息传给下一个函数进行处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> defer = Q.defer();</div><br><div class="line"></div><br><div class="line"><span class="comment">//一个模拟数据库</span></div><br><div class="line"><span class="keyword">var</span> users = [&#123;<span class="string">'name'</span>:<span class="string">'andrew'</span>,<span class="string">'passwd'</span>:<span class="string">'password'</span>&#125;];</div><br><div class="line"></div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params"></span>) </span>&#123;</div><br><div class="line"><span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">username</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">var</span> user;</div><br><div class="line">trueusers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><br><div class="line">truetrue<span class="keyword">if</span>(element.name === username) &#123;</div><br><div class="line">truetruetrueuser = element;</div><br><div class="line">truetrue&#125;</div><br><div class="line">true&#125;);</div><br><div class="line">true<span class="keyword">return</span> user;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line"><span class="comment">//promise链</span></div><br><div class="line">getUsername().then(<span class="function"><span class="keyword">function</span>(<span class="params">username</span>)</span>&#123;</div><br><div class="line"> <span class="keyword">return</span> getUser(username);</div><br><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123;</div><br><div class="line"> <span class="built_in">console</span>.log(user);</div><br><div class="line">&#125;);</div><br><div class="line"></div><br><div class="line">defer.resolve(<span class="string">'andrew'</span>);</div><br></pre></td></tr></table></figure><p>我们通过两个then达到让函数顺序执行的目的。</p><p>then的数量其实是没有限制的。当然，then的数量过多，要手动把他们链接起来是很麻烦的。比如</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">foo(initialVal).then(bar).then(baz).then(qux)</div><br></pre></td></tr></table></figure><p>这时我们需要用代码来动态制造promise链</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [foo,bar,baz,qux]</div><br><div class="line"><span class="keyword">var</span> result = Q(initialVal)</div><br><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</div><br><div class="line">trueresult = result.then(func)</div><br><div class="line">&#125;)</div><br><div class="line"><span class="keyword">return</span> result</div><br></pre></td></tr></table></figure><p>当然，我们可以再简洁一点</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [foo,bar,baz,qux]</div><br><div class="line">funcs.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,current</span>),<span class="title">Q</span>(<span class="params">initialVal</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">return</span> pre.then(current)</div><br><div class="line">&#125;)</div><br></pre></td></tr></table></figure><p>看一个具体的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">result</span>) </span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(result);</div><br><div class="line">true<span class="keyword">return</span> result+result;</div><br><div class="line">&#125;</div><br><div class="line"><span class="comment">//手动链接</span></div><br><div class="line">Q(<span class="string">'hello'</span>).then(foo).then(foo).then(foo); 									<span class="comment">//控制台输出： hello</span></div><br><div class="line">truetruetruetruetruetruetruetruetruetruetruetruetruetruetruetruetruetruetrue<span class="comment">//			   hellohello</span></div><br><div class="line">truetruetruetruetruetruetruetruetruetruetruetruetruetruetruetruetruetruetrue<span class="comment">//			   hellohellohello</span></div><br><div class="line"></div><br><div class="line"><span class="comment">//动态链接</span></div><br><div class="line"><span class="keyword">var</span> funcs = [foo,foo,foo];</div><br><div class="line"><span class="keyword">var</span> result = Q(<span class="string">'hello'</span>);</div><br><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</div><br><div class="line">trueresult = result.then(func);</div><br><div class="line">&#125;);</div><br><div class="line"><span class="comment">//精简后的动态链接</span></div><br><div class="line">funcs.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,current</span>)</span>&#123;</div><br><div class="line">true<span class="keyword">return</span> prev.then(current);</div><br><div class="line">&#125;,Q(<span class="string">'hello'</span>));</div><br></pre></td></tr></table></figure><p>对于promise链，最重要的是需要理解为什么这个链能够顺序执行。如果能够理解这点，那么以后自己写promise链可以说是轻车熟路啊。</p><h2 id="promise组合"><a href="#promise组合" class="headerlink" title="promise组合"></a>promise组合</h2><p>回到我们一开始读取文件内容的例子。如果现在让我们把它改写成promise链，是不是很简单呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>),</div><br><div class="line">truefs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</div><br><div class="line">true<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><br><div class="line">truetrue<span class="keyword">var</span> defer = Q.defer();</div><br><div class="line">truetruefs.readFile(fileName,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><br><div class="line">truetrue  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</div><br><div class="line">truetruetrue<span class="built_in">console</span>.log(data);</div><br><div class="line">truetruetruedefer.resolve();</div><br><div class="line">truetrue  &#125;</div><br><div class="line">truetrue&#125;)</div><br><div class="line">truetrue<span class="keyword">return</span> defer.promise;</div><br><div class="line">true&#125;</div><br><div class="line">&#125;</div><br><div class="line"><span class="comment">//手动链接</span></div><br><div class="line">printFileContent(<span class="string">'sample01.txt'</span>)()</div><br><div class="line">true.then(printFileContent(<span class="string">'sample02.txt'</span>))</div><br><div class="line">true.then(printFileContent(<span class="string">'sample03.txt'</span>))</div><br><div class="line">true.then(printFileContent(<span class="string">'sample04.txt'</span>));   <span class="comment">//控制台顺序打印sample01到sample04的内容</span></div><br></pre></td></tr></table></figure><p>很有成就感是不是。然而如果仔细分析，我们会发现为什么要他们顺序执行呢，如果他们能够并行执行不是更好吗? 我们只需要在他们都执行完成之后，得到他们的执行结果就可以了。</p><p>我们可以通过Q.all([promise1,promise2…])将多个promise组合成一个promise返回。 注意：</p><ol><li>当all里面所有的promise都fulfil时，Q.all返回的promise状态变成fulfil</li><li>当任意一个promise被reject时，Q.all返回的promise状态立即变成reject</li></ol><p>我们来把上面读取文件内容的例子改成并行执行吧</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> *读取文件内容</div><br><div class="line"> *@private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</div><br><div class="line">truetrue<span class="comment">//Todo: 这段代码不够简洁。可以使用Q.denodeify来简化</span></div><br><div class="line">truetrue<span class="keyword">var</span> defer = Q.defer();</div><br><div class="line">truetruefs.readFile(fileName,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><br><div class="line">truetrue  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</div><br><div class="line">truetruetrue<span class="built_in">console</span>.log(data);</div><br><div class="line">truetruetruedefer.resolve(fileName + <span class="string">' success '</span>);</div><br><div class="line">truetrue  &#125;<span class="keyword">else</span> &#123;</div><br><div class="line">truetruetruedefer.reject(fileName + <span class="string">' fail '</span>);</div><br><div class="line">truetrue  &#125;</div><br><div class="line">truetrue&#125;)</div><br><div class="line">truetrue<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line">Q.all([printFileContent(<span class="string">'sample01.txt'</span>),printFileContent(<span class="string">'sample02.txt'</span>),printFileContent(<span class="string">'sample03.txt'</span>),printFileContent(<span class="string">'sample04.txt'</span>)])</div><br><div class="line">true.then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</div><br><div class="line">truetrue<span class="built_in">console</span>.log(success);</div><br><div class="line">true&#125;); <span class="comment">//控制台打印各个文件内容 顺序不一定</span></div><br></pre></td></tr></table></figure><p>现在知道Q.all会在任意一个promise进入reject状态后立即进入reject状态。如果我们需要等到所有的promise都发生状态后(有的fulfil, 有的reject)，再转换Q.all的状态, 这时我们可以使用Q.allSettled</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>),</div><br><div class="line">truefs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> *读取文件内容</div><br><div class="line"> *@private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</div><br><div class="line">true<span class="comment">//Todo: 这段代码不够简洁。可以使用Q.denodeify来简化</span></div><br><div class="line">true<span class="keyword">var</span> defer = Q.defer();</div><br><div class="line">truefs.readFile(fileName,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><br><div class="line">true  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</div><br><div class="line">truetrue<span class="built_in">console</span>.log(data);</div><br><div class="line">truetruedefer.resolve(fileName + <span class="string">' success '</span>);</div><br><div class="line">true  &#125;<span class="keyword">else</span> &#123;</div><br><div class="line">truetruedefer.reject(fileName + <span class="string">' fail '</span>);</div><br><div class="line">true  &#125;</div><br><div class="line">true&#125;)</div><br><div class="line">true<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"></div><br><div class="line">Q.allSettled([printFileContent(<span class="string">'nosuchfile.txt'</span>),printFileContent(<span class="string">'sample02.txt'</span>),printFileContent(<span class="string">'sample03.txt'</span>),printFileContent(<span class="string">'sample04.txt'</span>)])</div><br><div class="line">true.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</div><br><div class="line">truetrueresults.forEach(</div><br><div class="line">truetruetrue<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><br><div class="line">truetruetruetrue<span class="built_in">console</span>.log(result.state);</div><br><div class="line">truetruetrue&#125;</div><br><div class="line">truetrue);</div><br><div class="line">true&#125;);</div><br></pre></td></tr></table></figure><h2 id="结束promise链"><a href="#结束promise链" class="headerlink" title="结束promise链"></a>结束promise链</h2><p>通常，对于一个promise链，有两种结束的方式。第一种方式是返回最后一个promise</p><p>如 <code>return foo().then(bar);</code></p><p>第二种方式就是通过done来结束promise链</p><p>如 <code>foo().then(bar).done()</code></p><p>为什么需要通过done来结束一个promise链呢? 如果在我们的链中有错误没有被处理，那么在一个正确结束的promise链中，这个没被处理的错误会通过异常抛出。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> *@private</div><br><div class="line"> */</div><br><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params">msg,timeout,opt</span>) </span>&#123;</div><br><div class="line">true<span class="keyword">var</span> defer = Q.defer();</div><br><div class="line">truesetTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><br><div class="line">true<span class="built_in">console</span>.log(msg);</div><br><div class="line">truetrue<span class="keyword">if</span>(opt)</div><br><div class="line">truetruetruedefer.reject(msg);</div><br><div class="line">truetrue<span class="keyword">else</span></div><br><div class="line">truetruetruedefer.resolve(msg);</div><br><div class="line">true&#125;,timeout);</div><br><div class="line">true<span class="keyword">return</span> defer.promise;</div><br><div class="line">&#125;</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> *没有用done()结束的promise链</div><br><div class="line"> *由于getPromse('2',2000,'opt')返回rejected, getPromise('3',1000)就没有执行</div><br><div class="line"> *然后这个异常并没有任何提醒，是一个潜在的bug</div><br><div class="line"> */</div><br><div class="line">getPromise(<span class="string">'1'</span>,<span class="number">3000</span>)</div><br><div class="line">true.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">'2'</span>,<span class="number">2000</span>,<span class="string">'opt'</span>)&#125;)</div><br><div class="line">true.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">'3'</span>,<span class="number">1000</span>)&#125;);</div><br><div class="line"><span class="comment">/**</span></div><br><div class="line"> *用done()结束的promise链</div><br><div class="line"> *有异常抛出</div><br><div class="line"> */</div><br><div class="line">getPromise(<span class="string">'1'</span>,<span class="number">3000</span>)</div><br><div class="line">true.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">'2'</span>,<span class="number">2000</span>,<span class="string">'opt'</span>)&#125;)</div><br><div class="line">true.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">'3'</span>,<span class="number">1000</span>)&#125;)</div><br><div class="line">true.done();</div><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>当你理解完上面所有的知识点时，你就会正确高效的使用promise了。本节只是讲了promise的原理和几个基本的API，不过你掌握了这些之后，再去看q的文档，应该很容易就能理解各个api的意图。</p></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/7907969" alt="落月"><p class="site-author-name" itemprop="name">落月</p><p class="site-description motion-element" itemprop="description">不知乘月几人归，落月摇情满江树。</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/"><span class="site-state-item-count">0</span> <span class="site-state-item-name">日志</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#《使用-promise-替代回调函数》"><span class="nav-number">1.</span> <span class="nav-text">《使用 promise 替代回调函数》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#知识点"><span class="nav-number">1.1.</span> <span class="nav-text">知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课程内容"><span class="nav-number">1.2.</span> <span class="nav-text">课程内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise基本概念"><span class="nav-number">1.3.</span> <span class="nav-text">promise基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise的传递"><span class="nav-number">1.4.</span> <span class="nav-text">promise的传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法传递"><span class="nav-number">1.5.</span> <span class="nav-text">方法传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise链"><span class="nav-number">1.6.</span> <span class="nav-text">promise链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise组合"><span class="nav-number">1.7.</span> <span class="nav-text">promise组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结束promise链"><span class="nav-number">1.8.</span> <span class="nav-text">结束promise链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结束语"><span class="nav-number">1.9.</span> <span class="nav-text">结束语</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright text-center">今夜还吹着风，想起你好温柔，有你的日子分外的轻松。<br>也不是无影踪，只是想你太浓。</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/jquery/pjax.js?v=1.9.6"></script><script type="text/javascript" src="/vendors/jquery/nprogess.js?v=0.2.0"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/static/js/src/utils.js?v=1.0.1"></script><script type="text/javascript" src="/static/js/src/motion.js?v=1.0.1"></script><script type="text/javascript" src="/static/js/src/bootstrap.js?v=1.0.1"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=r.url,i=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){i=s.indexOf(e),l=n.indexOf(e),0>i&&0>l?c=!1:(0>l&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;0>u&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").mousedown(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html><!-- rebuild by neat -->