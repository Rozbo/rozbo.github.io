<!-- build time:2016-06-04 16:39:31 --><!doctype html><html class="theme-next mist use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.lug.ustc.edu.cn//css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/static/css/main.css?v=1.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="落月博客,落月,落月助手,落月切牌器,落月官方网站"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.0.1"><meta name="description" content="《何为 connect 中间件》目标理解中间件的概念了解 Connect 的实现课程内容原生 httpServer 遇到的问题中间件思想Connect 实现Express 简介这是从 httpServer 到 Express 的升级过程。HTTPNodejs 的经典 httpServer 代码var http = require(&apos;http&apos;);var server = http.createSe"><meta property="og:type" content="website"><meta property="og:title" content="落月官方网站"><meta property="og:url" content="http://post.zz173.com/node1/lesson18/README.html"><meta property="og:site_name" content="落月官方网站"><meta property="og:description" content="《何为 connect 中间件》目标理解中间件的概念了解 Connect 的实现课程内容原生 httpServer 遇到的问题中间件思想Connect 实现Express 简介这是从 httpServer 到 Express 的升级过程。HTTPNodejs 的经典 httpServer 代码var http = require(&apos;http&apos;);var server = http.createSe"><meta property="og:updated_time" content="2016-04-26T14:20:42.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="落月官方网站"><meta name="twitter:description" content="《何为 connect 中间件》目标理解中间件的概念了解 Connect 的实现课程内容原生 httpServer 遇到的问题中间件思想Connect 实现Express 简介这是从 httpServer 到 Express 的升级过程。HTTPNodejs 的经典 httpServer 代码var http = require(&apos;http&apos;);var server = http.createSe"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:void 0,author:"博主"}}</script><title>| 落月官方网站</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">落月官方网站</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">落月博客post.zz173.com</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-books"><a href="/books.html" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>menu.books</a></li><li class="menu-item menu-item-tools"><a href="/tools.html" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i><br>menu.tools</a></li><li class="menu-item menu-item-blog"><a href="/post" rel="section"><i class="menu-item-icon fa fa-fw fa-pencil-square-o"></i><br>博客</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><h1 id="《何为-connect-中间件》"><a href="#《何为-connect-中间件》" class="headerlink" title="《何为 connect 中间件》"></a>《何为 connect 中间件》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>理解中间件的概念</li><li>了解 Connect 的实现</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ol><li>原生 httpServer 遇到的问题</li><li>中间件思想</li><li>Connect 实现</li><li>Express 简介</li></ol><p>这是从 httpServer 到 Express 的升级过程。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>Nodejs 的经典 httpServer 代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(requestHandler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'hello visitor!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>里面的函数 <code>requestHandler</code> 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。</p><p>通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 <code>hello visitor!</code>。</p><p>然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 检测请求中请求体是否存在，若存在则解析请求体；</span><br><span class="line">1. 查看请求体中的id是否存在，若存在则去数据库查询；</span><br><span class="line">1. 根据数据库结果返回约定的值；</span><br></pre></td></tr></table></figure><p>我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。</p><p>实现代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBody</span>(<span class="params">req, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据http协议从req中解析body</span></span><br><span class="line">  callback(<span class="literal">null</span>, body);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIdInDatabase</span>(<span class="params">body, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据body.id在Database中检测，返回结果</span></span><br><span class="line">  callback(<span class="literal">null</span>, dbResult);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnResult</span>(<span class="params">dbResult, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dbResult &amp;&amp; dbResult.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res.end(<span class="string">'true'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'false'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">    checkIdInDatabase(body, <span class="function"><span class="keyword">function</span>(<span class="params">err, dbResult</span>) </span>&#123;</span><br><span class="line">      returnResult(dbResult, res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解决方案解决了包含三个步骤的业务问题，出现了3个 <code>});</code> 还有3个 <code>err</code> 需要处理，上面的写法可以得达到预期效果。</p><p>然而，业务逻辑越来越复杂，会出发展成30个回调逻辑，那么就出现了30个 <code>});</code> 及30个 <code>err</code>异常。更严重的是，到时候写代码根本看不清自己写的逻辑在30层中的哪一层，极其容易出现 <strong>多次返回</strong> 或返回地方不对等问题，这就是 <strong>回调金字塔</strong> 问题了。</p><p>大多数同学应该能想到解决回调金字塔的办法，朴灵的《深入浅出Node.js》里讲到的三种方法。下面列举了这三种方法加上ES6新增的Generator，共四种解决办法。</p><ul><li><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">EventProxy</a> —— 事件发布订阅模式(第四课讲到)</li><li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">BlueBird</a> —— Promise方案(第十七课讲到)</li><li><a href="https://github.com/caolan/async" target="_blank" rel="external">Async</a> —— 异步流程控制库(第五课讲到)</li><li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">Generator</a> —— ES6原生Generator</li></ul><p>理论上，这四种都能解决回调金字塔问题。而Connect和Express用的是 <code>类似异步流程控制的思想</code> 。</p><p><a name="next"></a> 关于异步流程控制库下面简要介绍下，或移步<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="external">@第五课</a>。 异步流程控制库首先要求用户传入待执行的函数列表，记为funlist。流程控制库的任务是让这些函数 <strong>顺序执行</strong> 。</p><p>callback是控制顺序执行的关键，funlist里的函数每当调用callback会执行下一个funlist里的函数</p><p>我们动手实现一个类似的链式调用，其中 <code>funlist</code> 更名为 <code>middlewares</code>、<code>callback</code> 更名为 <code>next</code>，码如下：</p><p><a name="middlewares" comment="middlewares锚点"></a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> middlewares = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">      req.body = body;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    checkIdInDatabase(req.body.id, <span class="function"><span class="keyword">function</span>(<span class="params">err, rows</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">      res.dbResult = rows;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.dbResult &amp;&amp; res.dbResult.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      res.end(<span class="string">'true'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.end(<span class="string">'false'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//由middlewares链式调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.end(<span class="string">'error:'</span>, err.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i&lt;middlewares.length) &#123;</span><br><span class="line">      middlewares[i++](req, res, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//触发第一个middleware</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面用middlewares+next完成了业务逻辑的 <code>链式调用</code>，而middlewares里的每个函数，都是一个 <code>中间件</code>。</p><p>整体思路是：</p><ol><li>将所有 <code>处理逻辑函数(中间件)</code> 存储在一个list中；</li><li>请求到达时 <code>循环调用</code> list中的 <code>处理逻辑函数(中间件)</code>；</li></ol><h1 id="Connect的实现"><a href="#Connect的实现" class="headerlink" title="Connect的实现"></a><a href="https://github.com/senchalabs/connect" target="_blank" rel="external">Connect</a>的实现</h1><p>Connect的思想跟上面阐述的思想基本一样，先将处理逻辑存起来，然后循环调用。</p><p>Connect中主要有五个函数 PS: Connect的核心代码是200+行，建议对照<a href="https://github.com/senchalabs/connect/blob/master/index.js" target="_blank">源码</a>看下面的函数介绍。</p><table><thead><tr><th>函数名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>createServer</td><td style="text-align:center">包装httpServer形成app</td></tr><tr><td>listen</td><td style="text-align:center">监听端口函数</td></tr><tr><td>use</td><td style="text-align:center">向middlewares里面放入业务逻辑</td></tr><tr><td>handle</td><td style="text-align:center">上一章的requestHandler函数增强版</td></tr><tr><td>call</td><td style="text-align:center">业务逻辑的真正执行者</td></tr></tbody></table><h2 id="createServer"><a href="#createServer" class="headerlink" title="createServer()"></a>createServer()</h2><p><strong>输入</strong>:</p><p>无</p><p><strong>执行过程</strong>:</p><ol><li>app是一个函数对象(包含handle方法)</li><li>app具有Event所有属性(详见<a href="https://github.com/jaredhanson/utils-merge" target="_blank" rel="external">utils-merge</a>，十行代码)</li><li>app有route属性(路由)、和stack属性(用于存储中间件，类似上面的<a href="#middlewares">middlewares</a>)</li></ol><p><strong>输出</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     app is function(req, res, next) &#123;...&#125;;</span><br><span class="line">      |</span><br><span class="line">  +---+---+</span><br><span class="line">  |  has  |</span><br><span class="line">route   stack</span><br></pre></td></tr></table></figure><p>##app.use(route, fn)</p><p>作用是向stack中添加 <code>逻辑处理函数</code> (中间件)。</p><p><strong>输入</strong>:</p><ol><li>route 可省略，默认’/‘</li><li>fn 具体的业务处理逻辑</li></ol><p><strong>tips:</strong></p><p>上面的fn表示处理逻辑，它可以是</p><ol><li>一个普通的 <code>function(req,res[,next]){}</code>；</li><li>一个<a href="https://lodejs.org/api/http.html#http_class_http_server" target="_blank" rel="external">httpServer</a>；</li><li>另一个connect的app对象(<strong>sub app特性</strong>)；</li></ol><p>由于它们的本质都是 <code>处理逻辑</code>，都可以用一个 <code>function(req,res,next){}</code>将它们概括起来，Connect把他们都转化为这个函数，然后把它们存起来。</p><p>如何将这三种分别转换为 function(req, res, next) {}的形式呢？</p><ol><li>不用转换；</li><li>httpServer的定义是“对事件’request’后handler的对象”，我们可以从httpServer.listeners(‘request’)中得到这个函数；</li><li>另一个connect对象，而connect()返回的app就是function(req, res, out) {}；</li></ol><p><strong>执行过程</strong>:</p><ol><li>将三种<code>处理逻辑</code>统一转换为<code>function(req,res,next){}</code>的形式表示。</li><li>把这个<code>处理逻辑</code>与route一起，放入<code>stack</code>中(存储处理逻辑，route用来匹配路由)</li></ol><p>核心代码片段</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//route是路由路径，handle是一个`function(req, res, next) &#123;...&#125;`形式的业务逻辑</span></span><br><span class="line"><span class="keyword">this</span>.stack.push(&#123; route: path, handle: handle &#125;);</span><br></pre></td></tr></table></figure><p><strong>返回</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回自己，可以完成链式调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.use(<span class="string">'/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.stack.push(&#123;route: <span class="string">'/api'</span>, handle: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;&#125;);</span><br></pre></td></tr></table></figure><p>最后，app.stack里 <strong>顺序存储</strong> 了所有的 <strong>逻辑处理函数</strong> (中间件)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.stack = [function1, function2, function3, ... function30];</span><br></pre></td></tr></table></figure><h2 id="app-handle-req-res-out"><a href="#app-handle-req-res-out" class="headerlink" title="app.handle(req, res, out)"></a>app.handle(req, res, out)</h2><p>这个函数就是请求到达时，负责 <code>顺序调用</code> 我们存储在stack中的 <code>逻辑处理函数</code> (中间件)函数，类似上一章的requestHandler。</p><p><strong>输入:</strong></p><ol><li>req是Nodejs本身的可读流，不做过多介绍</li><li>res是Nodejs本身的可写流，不做过多介绍</li><li>out是为了Connect的 <strong>sub app特性</strong> 而设计的参数，这个特性可以暂时忽略，这个参数我们暂时不关心</li></ol><p><strong>处理过程:</strong></p><p>可以回头看一下上面的<a href="#middlewares">requestHandler函数</a>，handle的实现是这个函数的增强版</p><ol><li>取得stack(存储<code>逻辑处理函数</code>列表)，index(列表下标)</li><li>构建next函数，next的作用是执行下一个<code>逻辑处理函数</code></li><li>触发第一个next，触发链式调用</li></ol><p><strong>next函数实现:</strong></p><p>next函数实现在handle函数体内，用来<code>顺序执行处理逻辑</code>，它是异步流程控制库的核心，不明白它的作用请看<a href="#next">上面的异步流程控制库简介</a></p><p>path是请求路径，route是<code>逻辑处理函数</code>自带的属性。</p><ol><li>取得下一个<code>逻辑处理函数</code>;</li><li>若路由不匹配，跳过此逻辑;</li><li>若路由匹配<a href="#call">下面的call</a>执行匹配到的<code>逻辑处理函数</code></li></ol><p>tips: 跟上一章最后的代码一样，每个<code>逻辑处理函数</code>调用<code>next</code>来让后面的函数执行，存储在stack中的函数就实现了<code>链式调用</code>。不一定所有的函数都在返回的时候才调用<code>next</code>，为了不影响效率，有的函数可能先调用next，然而自己还没有返回，继续做自己的事情。</p><p>核心代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取下一个逻辑逻辑处理函数</span></span><br><span class="line"><span class="number">1</span>:  <span class="keyword">var</span> layer = stack[index++];</span><br><span class="line"><span class="comment">//不匹配时跳过</span></span><br><span class="line"><span class="number">2</span>:  <span class="keyword">if</span> (path.toLowerCase().substr(<span class="number">0</span>, route.length) !== route.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//匹配时执行</span></span><br><span class="line"><span class="number">3</span>:  call(layer.handle, route, err, req, res, next);</span><br></pre></td></tr></table></figure><p><strong>返回:</strong></p><p>无</p><p><strong>总结:</strong></p><p>画图总结</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request come</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware1 :  不匹配路由，skip</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware2 :  匹配路由，执行</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware3 :  匹配路由，执行</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware4 :  不匹配路由，skip</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p><a name="call"></a></p><p>##call(handle, route, err, req, res, next)</p><blockquote><p>这里有个比较有趣的知识，<code>console.log(Function.length)</code>会返回函数定义的参数个数。值跟在函数体内执行<code>arguments.length</code>一样。</p></blockquote><p>Connect中规定<code>function(err, req, res, next) {}</code>形式为错误处理函数，<code>function(req, res, next) {}</code>为正常的业务逻辑处理函数。那么，可以根据Function.length以判断它是否为错误处理函数。</p><p><strong>输入:</strong></p><table><thead><tr><th>参数名</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>handle</td><td style="text-align:center">逻辑处理函数</td></tr><tr><td>route</td><td style="text-align:center">路由</td></tr><tr><td>err</td><td style="text-align:center">是否发生过错误</td></tr><tr><td>req</td><td style="text-align:center">Nodejs对象</td></tr><tr><td>res</td><td style="text-align:center">Nodejs对象</td></tr><tr><td>next</td><td style="text-align:center">next函数</td></tr></tbody></table><p><strong>处理过程:</strong></p><ol><li>是否有错误，本次handle是否是错误处理函数;</li><li>若有错误且handle为错误处理函数，则执行handle，本函数返回;</li><li>若没错误且handle不是错误处理函数，则执行handle，本函数返回;</li><li>如果上面两个都不满足，不执行handle，本函数调用next，返回;</li></ol><p><strong>返回:</strong></p><p>无</p><p><strong>总结:</strong></p><p>call函数是一个执行者，根据当前<code>错误情况</code>和<code>handle类型</code>决定<code>是否执行</code>当前的handle。</p><p>##listen</p><p>创建一个httpServer，将Connect自己的业务逻辑作为requestHandler，监听端口</p><p>代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><p>##图解Connect</p><p>Connect将中间件存储在app.stack中，通过构造handle中的next函数在请求到来时依次调用这些中间件。</p><p>图形总结</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request               app(out)</span><br><span class="line">   |                          yes</span><br><span class="line">   +------------------&gt;match?-----&gt;middleware1</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        next&lt;----------+</span><br><span class="line">                         |</span><br><span class="line">                         v    yes</span><br><span class="line">                      match?------&gt;middleware2</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        next&lt;----------+</span><br><span class="line">                         |</span><br><span class="line">                         v    yes</span><br><span class="line">                      match?------&gt;middleware3</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        out&lt;-----------+</span><br><span class="line">                         |</span><br><span class="line">   +---------------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  end(response在处理过程中已经返回了)</span><br></pre></td></tr></table></figure><p>##Connect的subapp特性</p><p>我们再看看Connect是怎么实现subapp的，比较有趣。</p><p>什么是subapp?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sub_app = connect();</span><br><span class="line">var app = connect();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/route1&apos;, sub_app);</span><br><span class="line">// request path: &apos;/route1/route2&apos;</span><br><span class="line">// 由app接收到请求后，切割 path为&apos;/route2&apos;转交给sub_app的处理逻辑处理</span><br><span class="line">// 再由sub_app返回到app，由app继续向下执行处理逻辑</span><br></pre></td></tr></table></figure><p>结合上面的函数画图</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request               app(out1)                 sub_app(out2)</span><br><span class="line">   |</span><br><span class="line">   +---------------&gt;middleware1     +------------&gt;middleware1</span><br><span class="line">                         |          |                 |</span><br><span class="line">                        next        |                next</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                    middleware2-----+            middleware2</span><br><span class="line">                                                      |</span><br><span class="line">                       next&lt;--------+                next</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                     middleware3    |            middleware3</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                        out1        |                out2</span><br><span class="line">                         |          |                 |</span><br><span class="line">   +---------------------+          +-----------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  end(response在处理过程中已经返回了)</span><br></pre></td></tr></table></figure><p>完成上面的sub_app只需要做到两点：</p><ol><li>从app的调用链进入到sub_app的调用链中;</li><li>从sub_app的逻辑回到app的调用链中;</li></ol><p>connect在handle函数中的第三个参数<code>out</code>为这个特性实现提供可能。<code>out</code>的特点是<code>在middlewares链式调用完成以后调用</code>。<strong>那么将app的next作为sub_app的out传入sub_app的handle中</strong>可以做到sub_app自己的业务逻辑处理完后调用<code>out</code>，即处理权回到了本app的<code>next</code>手里。</p><p>上面图中的<code>sub_app.out2===app.next</code>，所以能完成逻辑的交接和sub app调用。</p><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a><a href="https://github.com/strongloop/express" target="_blank" rel="external">Express</a></h1><p>大家都知道Express是Connect的升级版。</p><p>Express不只是Connect的升级版，它还封装了很多对象来方便业务逻辑处理。Express里的Router是Connect的升级版。</p><p>Express大概可以分为几个模块</p><table><thead><tr><th>模块</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>router</td><td style="text-align:center">路由模块是Connect升级版</td></tr><tr><td>request</td><td style="text-align:center">经过Express封装的req对象</td></tr><tr><td>response</td><td style="text-align:center">经过Express封装的res对象</td></tr><tr><td>application</td><td style="text-align:center">app上面的各种默认设置</td></tr></tbody></table><p>简要介绍一下每个模块</p><p>##Router</p><p>在Connect中间件特性的基础上，加入了如下特性，是Connect的升级版</p><ol><li>正则匹配route;</li><li>进行将http的方法在route中分解开;</li></ol><p>##Request</p><p>在Request中集成了http.IncomingMessage(可读流+事件)，并在其上增加了新的属性，方便使用，我们最常用的应该是 req.param。</p><p>##Response</p><p>在Response中集成了http.ServerResponse(可写流+事件)，并在其上增加了很多方便返回的函数，有我们熟悉的res.json、 res.render、res.redirect、res.sendFile等等。</p><p>我们可以拓展它写一个res.sendPersonInfoById。</p><blockquote><p>关于流的题外话：req.pipe(res)的形式可以“完成发什么就返回什么”，而req.pipe(mylogic).pipe(res)可以添加自己的逻辑， 我们的业务逻辑是把流读为String/Object再进行逻辑处理，处理完再推送给另一个stream，有没有可能在流的层面进行逻辑解 耦提供服务呢？求大神解答了…至少这种写法在大流量、逻辑简单的情况下是有用的。</p></blockquote><p>##Application</p><p>除了上面的三个模块以外，还需要有个地方存储整个app的属性、设置等。比较常用的是app.engine函数设置模板引擎。</p><p>##Express小结</p><p>Express是一个中间件机制的httpServer框架，它本身实现了中间件机制，它也包含了中间件。比如3.x版本的Express 本身自带bodyParser、cookieSession等中间件，而在4.x中去掉了。包括TJ也写了很多中间件，比如node-querystring、 connect-redis等。</p><p>实现业务逻辑解耦时，中间件是从纵向的方面进行的逻辑分解，前面的中间件处理的结果可以给后面用，比如bodyParser把解析 body的结果放在req.body中，后面的逻辑都可以从req.body中取值。由于中间件是顺序执行的，errHandler一般都放在最后，而log类的中间件则放在比较前面。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Connect用流程控制库的回调函数及中间件的思想来解耦回调逻辑； <a href="https://github.com/koajs/koa" target="_blank" rel="external">Koa</a>用Generator方法解决回调问题；</p><p>我们应该也可以用事件、Promise的方式实现；</p><p>PS: 用事件来实现的话还挺期待的，能形成网状的相互调用。</p></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/7907969" alt="落月"><p class="site-author-name" itemprop="name">落月</p><p class="site-description motion-element" itemprop="description">不知乘月几人归，落月摇情满江树。</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/"><span class="site-state-item-count">0</span> <span class="site-state-item-name">日志</span></a></div></nav><div class="links-of-author motion-element"></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright text-center">今夜还吹着风，想起你好温柔，有你的日子分外的轻松。<br>也不是无影踪，只是想你太浓。</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/jquery/pjax.js?v=1.9.6"></script><script type="text/javascript" src="/vendors/jquery/nprogess.js?v=0.2.0"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/static/js/src/utils.js?v=1.0.1"></script><script type="text/javascript" src="/static/js/src/motion.js?v=1.0.1"></script><script type="text/javascript" src="/static/js/src/bootstrap.js?v=1.0.1"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=r.url,i=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){i=s.indexOf(e),l=n.indexOf(e),0>i&&0>l?c=!1:(0>l&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;0>u&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").mousedown(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html><!-- rebuild by neat -->